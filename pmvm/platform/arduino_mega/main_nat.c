#undef __FILE_ID__
#define __FILE_ID__ 0x0A
/**
 * PyMite usr native function file
 *
 * automatically created by pmImgCreator.py
 * on Sat Sep 17 02:52:49 2011
 *
 * DO NOT EDIT THIS FILE.
 * ANY CHANGES WILL BE LOST.
 *
 * @file    main_nat.c
 */

#define __IN_LIBNATIVE_C__
#include "pm.h"

/* From: ../../lib/avr.py */
#include <avr/io.h>
#include <util/delay.h>

/*
 * Common method for all port register operations
 */
PmReturn_t
_portX(volatile uint8_t *port,
       volatile uint8_t *direction,
       volatile uint8_t *pin)
{
   pPmObj_t pa;
   PmReturn_t retval = PM_RET_OK;

   switch (NATIVE_GET_NUM_ARGS())
   {
      /* If no argument is present, return PIN reg value */
      case 0:

        /* Read port and create a Python integer from its value */
        retval = int_new(*pin, &pa);

        /* Return the integer on the stack */
        NATIVE_SET_TOS(pa);
        break;

      /* If one argument is present, set port to that value */
      case 1:
         pa = NATIVE_GET_LOCAL(0);
         /* If the arg is not an integer, raise TypeError */
         if (OBJ_GET_TYPE(pa) != OBJ_TYPE_INT)
         {
           PM_RAISE(retval, PM_RET_EX_TYPE);
           break;
         }

         NATIVE_SET_TOS(PM_NONE);

         /* Set PORT to the low byte of the integer value */
         *port = ((pPmInt_t)pa)->val;
         break;

      /* If an invalid number of args are present, raise TypeError */
      default:
         PM_RAISE(retval, PM_RET_EX_TYPE);
         break;
    }

    return retval;
}


/*
 * Set a DDR register to the first Python argument
 */
PmReturn_t _ddrX(volatile uint8_t *direction)
{
   PmReturn_t retval = PM_RET_OK;
   pPmObj_t pa;
   if(NATIVE_GET_NUM_ARGS() != 1)
   {
      PM_RAISE(retval, PM_RET_EX_TYPE);
      return retval;
   }

   pa = NATIVE_GET_LOCAL(0);
   if (OBJ_GET_TYPE(pa) != OBJ_TYPE_INT)
   {
      PM_RAISE(retval, PM_RET_EX_TYPE);
      return retval;
   }

   *direction = (uint8_t) ((pPmInt_t)pa)->val;
   NATIVE_SET_TOS(PM_NONE);
   return retval;
}



/*
 * Loads the correct AVR port registers & direction address from the first
 * Python argument, and integer pin number (0-7) from second argument.
 * Port name argument is expected to be a single-character string with the port
 * letter ([a-dA-D])
 *
 * Both port_reg & port_reg arguments are optional.
 *
 * TODO: Look into putting this into a table in PROGMEM instead of a switch
 * statement
 */
PmReturn_t  _get_port_register(volatile uint8_t **pin_reg,
                               volatile uint8_t **port_reg,
                               volatile uint8_t **direction,
                               uint8_t *pin)
{
    pPmObj_t pa;
    pPmObj_t pb;
    PmReturn_t retval = PM_RET_OK;

    pa = NATIVE_GET_LOCAL(0);
    if (OBJ_GET_TYPE(pa) != OBJ_TYPE_STR)
    {
      PM_RAISE(retval, PM_RET_EX_TYPE);
      return retval;
    }

    pb = NATIVE_GET_LOCAL(1);
    if (OBJ_GET_TYPE(pb) != OBJ_TYPE_INT)
    {
      PM_RAISE(retval, PM_RET_EX_TYPE);
      return retval;
    }

    // Only single-character strings for the port number
    if ((((pPmString_t)pa)->length) != 1)
    {
      PM_RAISE(retval, PM_RET_EX_VAL);
      return retval;
    }

    // Find port & direction regs (TODO: Possibly make a PROGMEM lookup table)
    switch(((pPmString_t)pa)->val[0])
    {
      case 'a':
      case 'A':
        if(port_reg) *port_reg = &PORTA;
        if(pin_reg) *pin_reg = &PINA;
        *direction = &DDRA;
        break;
      case 'b':
      case 'B':
        if(port_reg) *port_reg = &PORTB;
        if(pin_reg) *pin_reg = &PINB;
        *direction = &DDRB;
        break;
      case 'c':
      case 'C':
#if defined(PORTC) && defined(PINC) && defined(DDRC)
        if(port_reg) *port_reg = &PORTC;
        if(pin_reg) *pin_reg = &PINC;
        *direction = &DDRC;
#endif
        break;
      case 'd':
      case 'D':
#if defined(PORTD) && defined(PIND) && defined(DDRD)
        if(port_reg) *port_reg = &PORTD;
        if(pin_reg) *pin_reg = &PIND;
        *direction = &DDRD;
#endif
        break;
      case 'e':
      case 'E':
#if defined(PORTE) && defined(PINE) && defined(DDRE)
        if(port_reg) *port_reg = &PORTE;
        if(pin_reg) *pin_reg = &PINE;
        *direction = &DDRE;
#endif
        break;
      case 'f':
      case 'F':
#if defined(PORTF) && defined(PINF) && defined(DDRF)
        if(port_reg) *port_reg = &PORTF;
        if(pin_reg) *pin_reg = &PINF;
        *direction = &DDRF;
#endif
        break;
      default:
        PM_RAISE(retval, PM_RET_EX_VAL);
        return retval;
    }

    // Check pin is in range
    if(((pPmInt_t)pb)->val < 0 || ((pPmInt_t)pb)->val > 7)
    {
        PM_RAISE(retval, PM_RET_EX_VAL);
        return retval;
    }
    *pin = ((pPmInt_t)pb)->val;

    return retval;
}


PmReturn_t
nat_placeholder_func(pPmFrame_t *ppframe)
{

    /*
     * Use placeholder because an index 
     * value of zero denotes the stdlib.
     * This function should not be called.
     */
    PmReturn_t retval;
    PM_RAISE(retval, PM_RET_EX_SYS);
    return retval;

}

PmReturn_t
nat_01_avr_portA(pPmFrame_t *ppframe)
{

    return _portX(&PORTA, &DDRA, &PINA);
    
}

PmReturn_t
nat_02_avr_ddrA(pPmFrame_t *ppframe)
{

    return _ddrX(&DDRA);
    
}

PmReturn_t
nat_03_avr_digitalRead(pPmFrame_t *ppframe)
{

    volatile uint8_t *port;
    volatile uint8_t *direction;
    uint8_t pin;
    PmReturn_t retval = PM_RET_OK;

    if(NATIVE_GET_NUM_ARGS() != 2)
    {
      PM_RAISE(retval, PM_RET_EX_TYPE);
      return retval;
    }

    retval = _get_port_register(&port, NULL, &direction, &pin);
    if(retval != PM_RET_OK)
      return retval;

    *direction &= ~(1<<pin); // Set pin to input
    pPmObj_t pa = (*port & (1<<pin)) ? PM_TRUE : PM_FALSE;
    NATIVE_SET_TOS(pa); // Push our result object onto the stack
    return retval;
    
}

PmReturn_t
nat_04_avr_digitalWrite(pPmFrame_t *ppframe)
{

    volatile uint8_t *port;
    volatile uint8_t *direction;
    uint8_t pin;
    pPmObj_t pc;
    PmReturn_t retval = PM_RET_OK;

    NATIVE_SET_TOS(PM_NONE);

    if(NATIVE_GET_NUM_ARGS() != 3)
    {
      PM_RAISE(retval, PM_RET_EX_TYPE);
      return retval;
    }

    retval = _get_port_register(NULL, &port, &direction, &pin);
    if(retval != PM_RET_OK)
      return retval;

    pc = NATIVE_GET_LOCAL(2);

    /* If the arg is not an integer, raise TypeError */
    if (OBJ_GET_TYPE(pc) != OBJ_TYPE_INT && OBJ_GET_TYPE(pc) != OBJ_TYPE_BOOL)
    {
      PM_RAISE(retval, PM_RET_EX_TYPE);
      return retval;
    }

    *direction |= (1<<pin); // Set pin to output

    if(((pPmInt_t)pc)->val)
      *port |= 1<<pin;
    else
      *port &= ~(1<<pin);
    return retval;
    
}

PmReturn_t
nat_05_avr_delay(pPmFrame_t *ppframe)
{

    PmReturn_t retval = PM_RET_OK;

    if(NATIVE_GET_NUM_ARGS() != 1)
    {
      PM_RAISE(retval, PM_RET_EX_TYPE);
      return retval;
    }

    pPmObj_t pa = NATIVE_GET_LOCAL(0);
    if (OBJ_GET_TYPE(pa) == OBJ_TYPE_INT)
    {
      _delay_ms((double) ((pPmInt_t)pa)->val);
    }
    else if (OBJ_GET_TYPE(pa) == OBJ_TYPE_FLT)
    {
      _delay_ms((double) ((pPmFloat_t)pa)->val);
    }
    else
    {
      PM_RAISE(retval, PM_RET_EX_TYPE);
    }

    NATIVE_SET_TOS(PM_NONE);
    return retval;
    
}

/* Native function lookup table */
pPmNativeFxn_t const usr_nat_fxn_table[] =
{
    nat_placeholder_func,
    nat_01_avr_portA,
    nat_02_avr_ddrA,
    nat_03_avr_digitalRead,
    nat_04_avr_digitalWrite,
    nat_05_avr_delay,
};
