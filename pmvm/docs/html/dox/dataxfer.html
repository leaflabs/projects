<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Python-on-a-chip: The uC/PC data transfer protocol</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.9 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
    </ul>
  </div>
</div>
<div class="contents">
<h1><a class="anchor" name="dataXfer">The uC/PC data transfer protocol </a></h1><h2><a class="anchor" name="dataXferIntro">
The PC/uC data transfer protocol</a></h2>
The uC data transfer protocol is a simple protocol to exchange data between a PC and a PIC over the UART. The example given below and implemented in this library applies to the PIC24/dsPIC33 series, though porting it to other microcontrollers is straightforward.<p>
 
  <object width="640" height="505"><param name="movie" value="http://www.youtube.com/v/3B60xpMLoFg&hl=en_US&fs=1&"></param><param name="allowFullScreen" value="true"></param><param name="allowscriptaccess" value="always"></param><embed src="http://www.youtube.com/v/3B60xpMLoFg&hl=en_US&fs=1&" type="application/x-shockwave-flash" allowscriptaccess="always" allowfullscreen="true" width="640" height="505"></embed></object>
  <h2><a class="anchor" name="usageSketch">
Usage sketch</a></h2>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include "<a class="code" href="pic24__all_8h.html">pic24_all.h</a>"</span>
<span class="preprocessor">#include "<a class="code" href="data_xfer_8h.html" title="Routines which implement the uC comm protocol.">dataXfer.h</a>"</span>

<span class="comment">// Indexes of all the variables to be transferred.</span>
<span class="keyword">enum</span> { U16_NUMCHARS_NDX, C_NDX };

<span class="comment">// Number of characters to print on each line.</span>
<span class="preprocessor">#define CHARS_PER_LINE 10</span>
<span class="preprocessor"></span>
<span class="keywordtype">int</span> main(<span class="keywordtype">void</span>) {
  <span class="keywordtype">char</span> c;
  <a class="code" href="pic24__generic_8h.html#4a2b22a29dec0305e3f9cbc69d0ff414">uint16</a> u16_numChars = 0;

  <span class="comment">// Initialize</span>
  <a class="code" href="pic24__util_8c.html#271372046d262eaed7e2d61decc50bb1">configBasic</a>(HELLO_MSG);
  <a class="code" href="data_xfer_8c.html#d9ef49b0cdb7a0c7d366165afecf21d8">initDataXfer</a>();

  <span class="comment">// All variables received by the PIC must be specified.</span>
  <span class="comment">// Params:  Index             Variable      PC can change  Format  Description</span>
  <a class="code" href="data_xfer_8h.html#9fe8ee550860f771452a32777eb99ccb">SPECIFY_VAR</a>(U16_NUMCHARS_NDX, u16_numChars, TRUE,          <span class="stringliteral">"%hu"</span>,  <span class="stringliteral">"Number of characters received"</span>);
  <a class="code" href="data_xfer_8h.html#9fe8ee550860f771452a32777eb99ccb">SPECIFY_VAR</a>(C_NDX,            c,            FALSE,         <span class="stringliteral">"%c"</span>,   <span class="stringliteral">"Character entered"</span>);

  <span class="keywordflow">while</span> (1) {
    <span class="comment">// For debug support, send the index and char received.</span>
    <a class="code" href="data_xfer_8c.html#c6168d273a011397bd3443acc52a9be4">sendVar</a>(U16_NUMCHARS_NDX);
    <a class="code" href="data_xfer_8c.html#c6168d273a011397bd3443acc52a9be4">sendVar</a>(C_NDX);

    <span class="comment">// Echo a character</span>
    c = <a class="code" href="data_xfer_8h.html#d6f6f11afad3f01823eeee09fbaf921a">inCharXfer</a>();
    <a class="code" href="pic24__serial_8c.html#b08fc14eef0812bc8ccc3f8e806a845f" title="A system-dependent macro to output one character.">outChar</a>(c);

    <span class="comment">// Add a CR every CHARS_PER_LINE</span>
    <span class="keywordflow">if</span> ((u16_numChars++ % CHARS_PER_LINE) == 0)
      <a class="code" href="pic24__serial_8c.html#b08fc14eef0812bc8ccc3f8e806a845f" title="A system-dependent macro to output one character.">outChar</a>(<span class="charliteral">'\n'</span>);
  }
}
</pre></div><h2><a class="anchor" name="dataXferExamples">
Examples</a></h2>
The following programs use the data transfer protocol, providing working examples of its usage.<ul>
<li>dataXfer_echo.c, which is given above.</li><li>dataXfer_demo.c, a more complete example.</li><li>ledpwm.c</li></ul>
<h2><a class="anchor" name="designGoals">
Design goals</a></h2>
<ul>
<li>Easy to use: no setup required to send variables; integrates with ISRs seamlessly by using getch/putch rather than direct assignment to UxRXREG/UxTXREG. Receive requires setup and returns a non-protocol character read or a variable read.</li><li>Excellent error reporting: PIC defines the protocol, pushing most errors onto the PC. Timeouts on the PIC and PC help spot errors. The PIC reports errors via text messages, which flow through to the PC.</li><li>Reasonably efficient (&gt; 100 Hz). Two bytes of overhead per variable (start, type).</li><li>Minimal PIC memory requirements: one pointer, one uint8, one bit per variable.</li><li>Can send/receive data in any order (not a fixed sequence): sendVar in any order, receiveVar receives any var (or even a non-protocol character, to make interaction via a menu work)</li></ul>
<h2><a class="anchor" name="errorCases">
Error cases</a></h2>
<ul>
<li>Timeout during received of a variable. In this case, the variable is only partially assigned; the PIC is reset, while the PC reports an error.</li><li>Sending in an ISR, which could cause timing problems. Fixing this really needs a trace buffer implementation.</li><li>Index of variable not the same between PIC and PC. The PIC names variables; the PC likewise only allows access to variables of the same name. However, the PC code will enforce variable name to number mapping, making this fairly uncommon (if the same name occurs twice, there's a problem).</li></ul>
<h2><a class="anchor" name="protocol">
Protocol</a></h2>
<ul>
<li><a class="el" href="data_xfer_impl_8h.html#c030999e4420a07577861b4d21b6801d">CMD_TOKEN</a> varBits data<ul>
<li>varBits = { v v v v v v l l} bitfield<ul>
<li>v = variable number (0-<a class="el" href="data_xfer_impl_8h.html#d5c4dcae370b21267b8b9e729d6f0a12">NUM_XFER_VARS</a>, 63 = special)</li><li>l = length (1-4 bytes, encoded as 0-3)/special code. Special codes:<ul>
<li>code = 0: escaped <a class="el" href="data_xfer_impl_8h.html#c030999e4420a07577861b4d21b6801d">CMD_TOKEN</a> : this is the value <a class="el" href="data_xfer_impl_8h.html#c030999e4420a07577861b4d21b6801d">CMD_TOKEN</a>, not the start of a command.</li><li>code = 1: long var</li><li>code = 2-3: Variable specification: data is size (1 byte), format <a class="el" href="namespacestring.html" title="Provides PyMite&#39;s string module.">string</a>, name, description (all zero-terminated). Code 2: send only var (PC may not modify); code 3: send/receive var.<ul>
<li>Only the PIC can send codes 2-3.</li></ul>
</li><li>For all but code 0, data = varNum (1 byte), length (1 byte), data (of length bytes). varNum must be between 1 and <a class="el" href="data_xfer_impl_8h.html#d5c4dcae370b21267b8b9e729d6f0a12">NUM_XFER_VARS</a>.</li></ul>
</li></ul>
</li><li>For non-special, data is len bytes. For special: see above. All lengths are len + 1, e.g. len = 0 is 1 byte, etc.</li></ul>
</li><li>Sending a <a class="el" href="data_xfer_impl_8h.html#c030999e4420a07577861b4d21b6801d">CMD_TOKEN</a>, whether inside a protocol packet or as a character not in a packet, must always be escaped with a <a class="el" href="data_xfer_impl_8h.html#c030999e4420a07577861b4d21b6801d">CMD_TOKEN</a> <a class="el" href="data_xfer_impl_8h.html#e0338256a3c57ff4a7d4b13d8e0478be">ESCAPED_CMD</a>. </li></ul>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Mon Oct 18 07:40:49 2010 for Python-on-a-chip by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.9 </small></address>
</body>
</html>
